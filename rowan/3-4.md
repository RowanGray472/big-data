---
Class: Big Data
---

1. more extra credit opportunities! these ones use docker swarm and kubernetes
2. quiz thurs on sql- each problem worth 2 points, 4 problems
3. remember the difference in `like` operators between the two- postgres is case sensitive and mysql is not
4. remember- nearly all points are lost through null value mishandling
5. we remove rows where `WHERE` evaluates to either `NULL` or `FALSE`
6. `WHERE` is before grouping, `HAVING` is after
7. there's never a situation where you have to use one of these or the other—it's just a syntactic convenience
8. you can include aggregate functions in a `HAVING` clause- you can't have one in `WHERE`
9. aggregates require `GROUP BY`, but not vice versa
10. any columns you select need an entry in `GROUP BY` except for aggregated columns
11. `/e` opens up a vim window that lets you use vim to edit your previously written bash commands
12. intuition- `HAVING` does filtering on a new table created by a grouping operation
13. without `ORDER BY` results are nondeterministic- computer scientists HATE this- creates tons of bugs
14. if you're getting different results it's because your `ORDER BY` clause is wrong
15. postgres is allowed to pick any order it wants in the clause so sometimes you get weird orders for hard to predict reasons
16. prereq courses pretty much all do join incorrectly
17. we're going to go into detail on what the joins actually do and how they interact with null values
18. `CROSS JOIN` - done with a comma
    1. concatenates the two tables horizontally
    2. gives you every possible combinations of the rows in both tables
    3. name comes from 'cross product' in set theory
    4. every other join is just a cross join plus other things
    5. not commonly used by itself
19. `INNER JOIN` is cross join plus a where clause
    1. this is `JOIN ON`
    2. so `JOIN basketb ON basketa.id = basketb.id` is `FROM basketa, basketb WHERE basketa.id=basketb.id`
    3. you can use non-equality joins too!
20. `USING` inside inner join has an equality condition and an identical column name in both tables
21. `NATURAL JOIN`
    1. joins the tables on all columns with shared names—you don't even need to specify!
22. self join - joining a table with itself—this will be on the quiz on thursday
    1. not a special join- any join can be a self-join if you're joining on the same table
    2. any time you're doing it you need to name the two tables with `AS` so we can reference both
    3. why would anyone ever do this?
23. cross, inner, and natural are associative and commutative
24. llms get essentially 100% on these
25. but next week we're moving into stuff they can't do
26. prepare for the quiz- do the quiz examples in the repo- once you've found what's difficult look at the quiz notes files
27. subqueries
    1. it's a `SELECT` statement inside of a `SELECT` statement
    2. not usually covered in intro clasess
    3. this is how they get huge
    4. anywhere you're allowed to use a table you can replace the table name with an expression that generates a table
    5. in postgres all subqueries MUST have aliases- sqlite doesn't require this
        1. means you have to name the tables generated by all subqueries
        2. you can delete AS and it'll be fine
28. Set operations- think unions and intersections
29. `UNION ALL` concatenates tables vertically
30. sqlite is weakly typed and postgres is strongly typed- so the types from a union dont' need to matchc in sqlite but they do in postgres
31. if we take away `ALL`, the union removes duplicates
